// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TrustWalletCore.proto

#ifndef PROTOBUF_INCLUDED_TrustWalletCore_2eproto
#define PROTOBUF_INCLUDED_TrustWalletCore_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_TrustWalletCore_2eproto 

namespace protobuf_TrustWalletCore_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_TrustWalletCore_2eproto
namespace TW {
namespace proto {
class BinanceCancelTradeOrder;
class BinanceCancelTradeOrderDefaultTypeInternal;
extern BinanceCancelTradeOrderDefaultTypeInternal _BinanceCancelTradeOrder_default_instance_;
class BinanceSendOrder;
class BinanceSendOrderDefaultTypeInternal;
extern BinanceSendOrderDefaultTypeInternal _BinanceSendOrder_default_instance_;
class BinanceSendOrder_Input;
class BinanceSendOrder_InputDefaultTypeInternal;
extern BinanceSendOrder_InputDefaultTypeInternal _BinanceSendOrder_Input_default_instance_;
class BinanceSendOrder_Output;
class BinanceSendOrder_OutputDefaultTypeInternal;
extern BinanceSendOrder_OutputDefaultTypeInternal _BinanceSendOrder_Output_default_instance_;
class BinanceSendOrder_Token;
class BinanceSendOrder_TokenDefaultTypeInternal;
extern BinanceSendOrder_TokenDefaultTypeInternal _BinanceSendOrder_Token_default_instance_;
class BinanceSignature;
class BinanceSignatureDefaultTypeInternal;
extern BinanceSignatureDefaultTypeInternal _BinanceSignature_default_instance_;
class BinanceSignature_PubKey;
class BinanceSignature_PubKeyDefaultTypeInternal;
extern BinanceSignature_PubKeyDefaultTypeInternal _BinanceSignature_PubKey_default_instance_;
class BinanceSigningInput;
class BinanceSigningInputDefaultTypeInternal;
extern BinanceSigningInputDefaultTypeInternal _BinanceSigningInput_default_instance_;
class BinanceTokenFreezeOrder;
class BinanceTokenFreezeOrderDefaultTypeInternal;
extern BinanceTokenFreezeOrderDefaultTypeInternal _BinanceTokenFreezeOrder_default_instance_;
class BinanceTokenUnfreezeOrder;
class BinanceTokenUnfreezeOrderDefaultTypeInternal;
extern BinanceTokenUnfreezeOrderDefaultTypeInternal _BinanceTokenUnfreezeOrder_default_instance_;
class BinanceTradeOrder;
class BinanceTradeOrderDefaultTypeInternal;
extern BinanceTradeOrderDefaultTypeInternal _BinanceTradeOrder_default_instance_;
class BinanceTransaction;
class BinanceTransactionDefaultTypeInternal;
extern BinanceTransactionDefaultTypeInternal _BinanceTransaction_default_instance_;
class BitcoinOutPoint;
class BitcoinOutPointDefaultTypeInternal;
extern BitcoinOutPointDefaultTypeInternal _BitcoinOutPoint_default_instance_;
class BitcoinSigningInput;
class BitcoinSigningInputDefaultTypeInternal;
extern BitcoinSigningInputDefaultTypeInternal _BitcoinSigningInput_default_instance_;
class BitcoinSigningInput_ScriptsEntry_DoNotUse;
class BitcoinSigningInput_ScriptsEntry_DoNotUseDefaultTypeInternal;
extern BitcoinSigningInput_ScriptsEntry_DoNotUseDefaultTypeInternal _BitcoinSigningInput_ScriptsEntry_DoNotUse_default_instance_;
class BitcoinUnspentTransaction;
class BitcoinUnspentTransactionDefaultTypeInternal;
extern BitcoinUnspentTransactionDefaultTypeInternal _BitcoinUnspentTransaction_default_instance_;
}  // namespace proto
}  // namespace TW
namespace google {
namespace protobuf {
template<> ::TW::proto::BinanceCancelTradeOrder* Arena::CreateMaybeMessage<::TW::proto::BinanceCancelTradeOrder>(Arena*);
template<> ::TW::proto::BinanceSendOrder* Arena::CreateMaybeMessage<::TW::proto::BinanceSendOrder>(Arena*);
template<> ::TW::proto::BinanceSendOrder_Input* Arena::CreateMaybeMessage<::TW::proto::BinanceSendOrder_Input>(Arena*);
template<> ::TW::proto::BinanceSendOrder_Output* Arena::CreateMaybeMessage<::TW::proto::BinanceSendOrder_Output>(Arena*);
template<> ::TW::proto::BinanceSendOrder_Token* Arena::CreateMaybeMessage<::TW::proto::BinanceSendOrder_Token>(Arena*);
template<> ::TW::proto::BinanceSignature* Arena::CreateMaybeMessage<::TW::proto::BinanceSignature>(Arena*);
template<> ::TW::proto::BinanceSignature_PubKey* Arena::CreateMaybeMessage<::TW::proto::BinanceSignature_PubKey>(Arena*);
template<> ::TW::proto::BinanceSigningInput* Arena::CreateMaybeMessage<::TW::proto::BinanceSigningInput>(Arena*);
template<> ::TW::proto::BinanceTokenFreezeOrder* Arena::CreateMaybeMessage<::TW::proto::BinanceTokenFreezeOrder>(Arena*);
template<> ::TW::proto::BinanceTokenUnfreezeOrder* Arena::CreateMaybeMessage<::TW::proto::BinanceTokenUnfreezeOrder>(Arena*);
template<> ::TW::proto::BinanceTradeOrder* Arena::CreateMaybeMessage<::TW::proto::BinanceTradeOrder>(Arena*);
template<> ::TW::proto::BinanceTransaction* Arena::CreateMaybeMessage<::TW::proto::BinanceTransaction>(Arena*);
template<> ::TW::proto::BitcoinOutPoint* Arena::CreateMaybeMessage<::TW::proto::BitcoinOutPoint>(Arena*);
template<> ::TW::proto::BitcoinSigningInput* Arena::CreateMaybeMessage<::TW::proto::BitcoinSigningInput>(Arena*);
template<> ::TW::proto::BitcoinSigningInput_ScriptsEntry_DoNotUse* Arena::CreateMaybeMessage<::TW::proto::BitcoinSigningInput_ScriptsEntry_DoNotUse>(Arena*);
template<> ::TW::proto::BitcoinUnspentTransaction* Arena::CreateMaybeMessage<::TW::proto::BitcoinUnspentTransaction>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace TW {
namespace proto {

// ===================================================================

class BitcoinOutPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BitcoinOutPoint) */ {
 public:
  BitcoinOutPoint();
  virtual ~BitcoinOutPoint();

  BitcoinOutPoint(const BitcoinOutPoint& from);

  inline BitcoinOutPoint& operator=(const BitcoinOutPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitcoinOutPoint(BitcoinOutPoint&& from) noexcept
    : BitcoinOutPoint() {
    *this = ::std::move(from);
  }

  inline BitcoinOutPoint& operator=(BitcoinOutPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BitcoinOutPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitcoinOutPoint* internal_default_instance() {
    return reinterpret_cast<const BitcoinOutPoint*>(
               &_BitcoinOutPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BitcoinOutPoint* other);
  friend void swap(BitcoinOutPoint& a, BitcoinOutPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitcoinOutPoint* New() const final {
    return CreateMaybeMessage<BitcoinOutPoint>(NULL);
  }

  BitcoinOutPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitcoinOutPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitcoinOutPoint& from);
  void MergeFrom(const BitcoinOutPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitcoinOutPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // uint32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // uint32 sequence = 3;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BitcoinOutPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 sequence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BitcoinUnspentTransaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BitcoinUnspentTransaction) */ {
 public:
  BitcoinUnspentTransaction();
  virtual ~BitcoinUnspentTransaction();

  BitcoinUnspentTransaction(const BitcoinUnspentTransaction& from);

  inline BitcoinUnspentTransaction& operator=(const BitcoinUnspentTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitcoinUnspentTransaction(BitcoinUnspentTransaction&& from) noexcept
    : BitcoinUnspentTransaction() {
    *this = ::std::move(from);
  }

  inline BitcoinUnspentTransaction& operator=(BitcoinUnspentTransaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BitcoinUnspentTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitcoinUnspentTransaction* internal_default_instance() {
    return reinterpret_cast<const BitcoinUnspentTransaction*>(
               &_BitcoinUnspentTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BitcoinUnspentTransaction* other);
  friend void swap(BitcoinUnspentTransaction& a, BitcoinUnspentTransaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitcoinUnspentTransaction* New() const final {
    return CreateMaybeMessage<BitcoinUnspentTransaction>(NULL);
  }

  BitcoinUnspentTransaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitcoinUnspentTransaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitcoinUnspentTransaction& from);
  void MergeFrom(const BitcoinUnspentTransaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitcoinUnspentTransaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes script = 2;
  void clear_script();
  static const int kScriptFieldNumber = 2;
  const ::std::string& script() const;
  void set_script(const ::std::string& value);
  #if LANG_CXX11
  void set_script(::std::string&& value);
  #endif
  void set_script(const char* value);
  void set_script(const void* value, size_t size);
  ::std::string* mutable_script();
  ::std::string* release_script();
  void set_allocated_script(::std::string* script);

  // .TW.proto.BitcoinOutPoint out_point = 1;
  bool has_out_point() const;
  void clear_out_point();
  static const int kOutPointFieldNumber = 1;
  private:
  const ::TW::proto::BitcoinOutPoint& _internal_out_point() const;
  public:
  const ::TW::proto::BitcoinOutPoint& out_point() const;
  ::TW::proto::BitcoinOutPoint* release_out_point();
  ::TW::proto::BitcoinOutPoint* mutable_out_point();
  void set_allocated_out_point(::TW::proto::BitcoinOutPoint* out_point);

  // int64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BitcoinUnspentTransaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr script_;
  ::TW::proto::BitcoinOutPoint* out_point_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BitcoinSigningInput_ScriptsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<BitcoinSigningInput_ScriptsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<BitcoinSigningInput_ScriptsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  BitcoinSigningInput_ScriptsEntry_DoNotUse();
  BitcoinSigningInput_ScriptsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const BitcoinSigningInput_ScriptsEntry_DoNotUse& other);
  static const BitcoinSigningInput_ScriptsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BitcoinSigningInput_ScriptsEntry_DoNotUse*>(&_BitcoinSigningInput_ScriptsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class BitcoinSigningInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BitcoinSigningInput) */ {
 public:
  BitcoinSigningInput();
  virtual ~BitcoinSigningInput();

  BitcoinSigningInput(const BitcoinSigningInput& from);

  inline BitcoinSigningInput& operator=(const BitcoinSigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitcoinSigningInput(BitcoinSigningInput&& from) noexcept
    : BitcoinSigningInput() {
    *this = ::std::move(from);
  }

  inline BitcoinSigningInput& operator=(BitcoinSigningInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BitcoinSigningInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitcoinSigningInput* internal_default_instance() {
    return reinterpret_cast<const BitcoinSigningInput*>(
               &_BitcoinSigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BitcoinSigningInput* other);
  friend void swap(BitcoinSigningInput& a, BitcoinSigningInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitcoinSigningInput* New() const final {
    return CreateMaybeMessage<BitcoinSigningInput>(NULL);
  }

  BitcoinSigningInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitcoinSigningInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitcoinSigningInput& from);
  void MergeFrom(const BitcoinSigningInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitcoinSigningInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated bytes private_key = 10;
  int private_key_size() const;
  void clear_private_key();
  static const int kPrivateKeyFieldNumber = 10;
  const ::std::string& private_key(int index) const;
  ::std::string* mutable_private_key(int index);
  void set_private_key(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_private_key(int index, ::std::string&& value);
  #endif
  void set_private_key(int index, const char* value);
  void set_private_key(int index, const void* value, size_t size);
  ::std::string* add_private_key();
  void add_private_key(const ::std::string& value);
  #if LANG_CXX11
  void add_private_key(::std::string&& value);
  #endif
  void add_private_key(const char* value);
  void add_private_key(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& private_key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_private_key();

  // map<string, bytes> scripts = 11;
  int scripts_size() const;
  void clear_scripts();
  static const int kScriptsFieldNumber = 11;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      scripts() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_scripts();

  // repeated .TW.proto.BitcoinUnspentTransaction utxo = 12;
  int utxo_size() const;
  void clear_utxo();
  static const int kUtxoFieldNumber = 12;
  ::TW::proto::BitcoinUnspentTransaction* mutable_utxo(int index);
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BitcoinUnspentTransaction >*
      mutable_utxo();
  const ::TW::proto::BitcoinUnspentTransaction& utxo(int index) const;
  ::TW::proto::BitcoinUnspentTransaction* add_utxo();
  const ::google::protobuf::RepeatedPtrField< ::TW::proto::BitcoinUnspentTransaction >&
      utxo() const;

  // string to_address = 4;
  void clear_to_address();
  static const int kToAddressFieldNumber = 4;
  const ::std::string& to_address() const;
  void set_to_address(const ::std::string& value);
  #if LANG_CXX11
  void set_to_address(::std::string&& value);
  #endif
  void set_to_address(const char* value);
  void set_to_address(const char* value, size_t size);
  ::std::string* mutable_to_address();
  ::std::string* release_to_address();
  void set_allocated_to_address(::std::string* to_address);

  // string change_address = 5;
  void clear_change_address();
  static const int kChangeAddressFieldNumber = 5;
  const ::std::string& change_address() const;
  void set_change_address(const ::std::string& value);
  #if LANG_CXX11
  void set_change_address(::std::string&& value);
  #endif
  void set_change_address(const char* value);
  void set_change_address(const char* value, size_t size);
  ::std::string* mutable_change_address();
  ::std::string* release_change_address();
  void set_allocated_change_address(::std::string* change_address);

  // int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // int64 byte_fee = 3;
  void clear_byte_fee();
  static const int kByteFeeFieldNumber = 3;
  ::google::protobuf::int64 byte_fee() const;
  void set_byte_fee(::google::protobuf::int64 value);

  // uint32 hash_type = 1;
  void clear_hash_type();
  static const int kHashTypeFieldNumber = 1;
  ::google::protobuf::uint32 hash_type() const;
  void set_hash_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BitcoinSigningInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> private_key_;
  ::google::protobuf::internal::MapField<
      BitcoinSigningInput_ScriptsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > scripts_;
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BitcoinUnspentTransaction > utxo_;
  ::google::protobuf::internal::ArenaStringPtr to_address_;
  ::google::protobuf::internal::ArenaStringPtr change_address_;
  ::google::protobuf::int64 amount_;
  ::google::protobuf::int64 byte_fee_;
  ::google::protobuf::uint32 hash_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceTransaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceTransaction) */ {
 public:
  BinanceTransaction();
  virtual ~BinanceTransaction();

  BinanceTransaction(const BinanceTransaction& from);

  inline BinanceTransaction& operator=(const BinanceTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTransaction(BinanceTransaction&& from) noexcept
    : BinanceTransaction() {
    *this = ::std::move(from);
  }

  inline BinanceTransaction& operator=(BinanceTransaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTransaction* internal_default_instance() {
    return reinterpret_cast<const BinanceTransaction*>(
               &_BinanceTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BinanceTransaction* other);
  friend void swap(BinanceTransaction& a, BinanceTransaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTransaction* New() const final {
    return CreateMaybeMessage<BinanceTransaction>(NULL);
  }

  BinanceTransaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTransaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTransaction& from);
  void MergeFrom(const BinanceTransaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTransaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes msgs = 1;
  int msgs_size() const;
  void clear_msgs();
  static const int kMsgsFieldNumber = 1;
  const ::std::string& msgs(int index) const;
  ::std::string* mutable_msgs(int index);
  void set_msgs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_msgs(int index, ::std::string&& value);
  #endif
  void set_msgs(int index, const char* value);
  void set_msgs(int index, const void* value, size_t size);
  ::std::string* add_msgs();
  void add_msgs(const ::std::string& value);
  #if LANG_CXX11
  void add_msgs(::std::string&& value);
  #endif
  void add_msgs(const char* value);
  void add_msgs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& msgs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msgs();

  // repeated bytes signatures = 2;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  const ::std::string& signatures(int index) const;
  ::std::string* mutable_signatures(int index);
  void set_signatures(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signatures(int index, ::std::string&& value);
  #endif
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const void* value, size_t size);
  ::std::string* add_signatures();
  void add_signatures(const ::std::string& value);
  #if LANG_CXX11
  void add_signatures(::std::string&& value);
  #endif
  void add_signatures(const char* value);
  void add_signatures(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signatures() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signatures();

  // string memo = 3;
  void clear_memo();
  static const int kMemoFieldNumber = 3;
  const ::std::string& memo() const;
  void set_memo(const ::std::string& value);
  #if LANG_CXX11
  void set_memo(::std::string&& value);
  #endif
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  ::std::string* mutable_memo();
  ::std::string* release_memo();
  void set_allocated_memo(::std::string* memo);

  // bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int64 source = 4;
  void clear_source();
  static const int kSourceFieldNumber = 4;
  ::google::protobuf::int64 source() const;
  void set_source(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceTransaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> msgs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signatures_;
  ::google::protobuf::internal::ArenaStringPtr memo_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 source_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceSignature_PubKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceSignature.PubKey) */ {
 public:
  BinanceSignature_PubKey();
  virtual ~BinanceSignature_PubKey();

  BinanceSignature_PubKey(const BinanceSignature_PubKey& from);

  inline BinanceSignature_PubKey& operator=(const BinanceSignature_PubKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSignature_PubKey(BinanceSignature_PubKey&& from) noexcept
    : BinanceSignature_PubKey() {
    *this = ::std::move(from);
  }

  inline BinanceSignature_PubKey& operator=(BinanceSignature_PubKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceSignature_PubKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSignature_PubKey* internal_default_instance() {
    return reinterpret_cast<const BinanceSignature_PubKey*>(
               &_BinanceSignature_PubKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BinanceSignature_PubKey* other);
  friend void swap(BinanceSignature_PubKey& a, BinanceSignature_PubKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSignature_PubKey* New() const final {
    return CreateMaybeMessage<BinanceSignature_PubKey>(NULL);
  }

  BinanceSignature_PubKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSignature_PubKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSignature_PubKey& from);
  void MergeFrom(const BinanceSignature_PubKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSignature_PubKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceSignature.PubKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceSignature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceSignature) */ {
 public:
  BinanceSignature();
  virtual ~BinanceSignature();

  BinanceSignature(const BinanceSignature& from);

  inline BinanceSignature& operator=(const BinanceSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSignature(BinanceSignature&& from) noexcept
    : BinanceSignature() {
    *this = ::std::move(from);
  }

  inline BinanceSignature& operator=(BinanceSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSignature* internal_default_instance() {
    return reinterpret_cast<const BinanceSignature*>(
               &_BinanceSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BinanceSignature* other);
  friend void swap(BinanceSignature& a, BinanceSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSignature* New() const final {
    return CreateMaybeMessage<BinanceSignature>(NULL);
  }

  BinanceSignature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSignature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSignature& from);
  void MergeFrom(const BinanceSignature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BinanceSignature_PubKey PubKey;

  // accessors -------------------------------------------------------

  // bytes pub_key = 1;
  void clear_pub_key();
  static const int kPubKeyFieldNumber = 1;
  const ::std::string& pub_key() const;
  void set_pub_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pub_key(::std::string&& value);
  #endif
  void set_pub_key(const char* value);
  void set_pub_key(const void* value, size_t size);
  ::std::string* mutable_pub_key();
  ::std::string* release_pub_key();
  void set_allocated_pub_key(::std::string* pub_key);

  // bytes signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // int64 account_number = 3;
  void clear_account_number();
  static const int kAccountNumberFieldNumber = 3;
  ::google::protobuf::int64 account_number() const;
  void set_account_number(::google::protobuf::int64 value);

  // int64 sequence = 4;
  void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceSignature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pub_key_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::int64 account_number_;
  ::google::protobuf::int64 sequence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceTradeOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceTradeOrder) */ {
 public:
  BinanceTradeOrder();
  virtual ~BinanceTradeOrder();

  BinanceTradeOrder(const BinanceTradeOrder& from);

  inline BinanceTradeOrder& operator=(const BinanceTradeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTradeOrder(BinanceTradeOrder&& from) noexcept
    : BinanceTradeOrder() {
    *this = ::std::move(from);
  }

  inline BinanceTradeOrder& operator=(BinanceTradeOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceTradeOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTradeOrder* internal_default_instance() {
    return reinterpret_cast<const BinanceTradeOrder*>(
               &_BinanceTradeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(BinanceTradeOrder* other);
  friend void swap(BinanceTradeOrder& a, BinanceTradeOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTradeOrder* New() const final {
    return CreateMaybeMessage<BinanceTradeOrder>(NULL);
  }

  BinanceTradeOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTradeOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTradeOrder& from);
  void MergeFrom(const BinanceTradeOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTradeOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes sender = 1;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const void* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string symbol = 3;
  void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // int64 ordertype = 4;
  void clear_ordertype();
  static const int kOrdertypeFieldNumber = 4;
  ::google::protobuf::int64 ordertype() const;
  void set_ordertype(::google::protobuf::int64 value);

  // int64 side = 5;
  void clear_side();
  static const int kSideFieldNumber = 5;
  ::google::protobuf::int64 side() const;
  void set_side(::google::protobuf::int64 value);

  // int64 price = 6;
  void clear_price();
  static const int kPriceFieldNumber = 6;
  ::google::protobuf::int64 price() const;
  void set_price(::google::protobuf::int64 value);

  // int64 quantity = 7;
  void clear_quantity();
  static const int kQuantityFieldNumber = 7;
  ::google::protobuf::int64 quantity() const;
  void set_quantity(::google::protobuf::int64 value);

  // int64 timeinforce = 8;
  void clear_timeinforce();
  static const int kTimeinforceFieldNumber = 8;
  ::google::protobuf::int64 timeinforce() const;
  void set_timeinforce(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceTradeOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int64 ordertype_;
  ::google::protobuf::int64 side_;
  ::google::protobuf::int64 price_;
  ::google::protobuf::int64 quantity_;
  ::google::protobuf::int64 timeinforce_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceCancelTradeOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceCancelTradeOrder) */ {
 public:
  BinanceCancelTradeOrder();
  virtual ~BinanceCancelTradeOrder();

  BinanceCancelTradeOrder(const BinanceCancelTradeOrder& from);

  inline BinanceCancelTradeOrder& operator=(const BinanceCancelTradeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceCancelTradeOrder(BinanceCancelTradeOrder&& from) noexcept
    : BinanceCancelTradeOrder() {
    *this = ::std::move(from);
  }

  inline BinanceCancelTradeOrder& operator=(BinanceCancelTradeOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceCancelTradeOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceCancelTradeOrder* internal_default_instance() {
    return reinterpret_cast<const BinanceCancelTradeOrder*>(
               &_BinanceCancelTradeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BinanceCancelTradeOrder* other);
  friend void swap(BinanceCancelTradeOrder& a, BinanceCancelTradeOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceCancelTradeOrder* New() const final {
    return CreateMaybeMessage<BinanceCancelTradeOrder>(NULL);
  }

  BinanceCancelTradeOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceCancelTradeOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceCancelTradeOrder& from);
  void MergeFrom(const BinanceCancelTradeOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceCancelTradeOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes sender = 1;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const void* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // string symbol = 2;
  void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // string refid = 4;
  void clear_refid();
  static const int kRefidFieldNumber = 4;
  const ::std::string& refid() const;
  void set_refid(const ::std::string& value);
  #if LANG_CXX11
  void set_refid(::std::string&& value);
  #endif
  void set_refid(const char* value);
  void set_refid(const char* value, size_t size);
  ::std::string* mutable_refid();
  ::std::string* release_refid();
  void set_allocated_refid(::std::string* refid);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceCancelTradeOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr refid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceSendOrder_Token : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceSendOrder.Token) */ {
 public:
  BinanceSendOrder_Token();
  virtual ~BinanceSendOrder_Token();

  BinanceSendOrder_Token(const BinanceSendOrder_Token& from);

  inline BinanceSendOrder_Token& operator=(const BinanceSendOrder_Token& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSendOrder_Token(BinanceSendOrder_Token&& from) noexcept
    : BinanceSendOrder_Token() {
    *this = ::std::move(from);
  }

  inline BinanceSendOrder_Token& operator=(BinanceSendOrder_Token&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceSendOrder_Token& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSendOrder_Token* internal_default_instance() {
    return reinterpret_cast<const BinanceSendOrder_Token*>(
               &_BinanceSendOrder_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(BinanceSendOrder_Token* other);
  friend void swap(BinanceSendOrder_Token& a, BinanceSendOrder_Token& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSendOrder_Token* New() const final {
    return CreateMaybeMessage<BinanceSendOrder_Token>(NULL);
  }

  BinanceSendOrder_Token* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSendOrder_Token>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSendOrder_Token& from);
  void MergeFrom(const BinanceSendOrder_Token& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSendOrder_Token* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string denom = 1;
  void clear_denom();
  static const int kDenomFieldNumber = 1;
  const ::std::string& denom() const;
  void set_denom(const ::std::string& value);
  #if LANG_CXX11
  void set_denom(::std::string&& value);
  #endif
  void set_denom(const char* value);
  void set_denom(const char* value, size_t size);
  ::std::string* mutable_denom();
  ::std::string* release_denom();
  void set_allocated_denom(::std::string* denom);

  // int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceSendOrder.Token)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr denom_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceSendOrder_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceSendOrder.Input) */ {
 public:
  BinanceSendOrder_Input();
  virtual ~BinanceSendOrder_Input();

  BinanceSendOrder_Input(const BinanceSendOrder_Input& from);

  inline BinanceSendOrder_Input& operator=(const BinanceSendOrder_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSendOrder_Input(BinanceSendOrder_Input&& from) noexcept
    : BinanceSendOrder_Input() {
    *this = ::std::move(from);
  }

  inline BinanceSendOrder_Input& operator=(BinanceSendOrder_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceSendOrder_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSendOrder_Input* internal_default_instance() {
    return reinterpret_cast<const BinanceSendOrder_Input*>(
               &_BinanceSendOrder_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BinanceSendOrder_Input* other);
  friend void swap(BinanceSendOrder_Input& a, BinanceSendOrder_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSendOrder_Input* New() const final {
    return CreateMaybeMessage<BinanceSendOrder_Input>(NULL);
  }

  BinanceSendOrder_Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSendOrder_Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSendOrder_Input& from);
  void MergeFrom(const BinanceSendOrder_Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSendOrder_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TW.proto.BinanceSendOrder.Token coins = 2;
  int coins_size() const;
  void clear_coins();
  static const int kCoinsFieldNumber = 2;
  ::TW::proto::BinanceSendOrder_Token* mutable_coins(int index);
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >*
      mutable_coins();
  const ::TW::proto::BinanceSendOrder_Token& coins(int index) const;
  ::TW::proto::BinanceSendOrder_Token* add_coins();
  const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >&
      coins() const;

  // bytes address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceSendOrder.Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token > coins_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceSendOrder_Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceSendOrder.Output) */ {
 public:
  BinanceSendOrder_Output();
  virtual ~BinanceSendOrder_Output();

  BinanceSendOrder_Output(const BinanceSendOrder_Output& from);

  inline BinanceSendOrder_Output& operator=(const BinanceSendOrder_Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSendOrder_Output(BinanceSendOrder_Output&& from) noexcept
    : BinanceSendOrder_Output() {
    *this = ::std::move(from);
  }

  inline BinanceSendOrder_Output& operator=(BinanceSendOrder_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceSendOrder_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSendOrder_Output* internal_default_instance() {
    return reinterpret_cast<const BinanceSendOrder_Output*>(
               &_BinanceSendOrder_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BinanceSendOrder_Output* other);
  friend void swap(BinanceSendOrder_Output& a, BinanceSendOrder_Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSendOrder_Output* New() const final {
    return CreateMaybeMessage<BinanceSendOrder_Output>(NULL);
  }

  BinanceSendOrder_Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSendOrder_Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSendOrder_Output& from);
  void MergeFrom(const BinanceSendOrder_Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSendOrder_Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TW.proto.BinanceSendOrder.Token coins = 2;
  int coins_size() const;
  void clear_coins();
  static const int kCoinsFieldNumber = 2;
  ::TW::proto::BinanceSendOrder_Token* mutable_coins(int index);
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >*
      mutable_coins();
  const ::TW::proto::BinanceSendOrder_Token& coins(int index) const;
  ::TW::proto::BinanceSendOrder_Token* add_coins();
  const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >&
      coins() const;

  // bytes address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceSendOrder.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token > coins_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceSendOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceSendOrder) */ {
 public:
  BinanceSendOrder();
  virtual ~BinanceSendOrder();

  BinanceSendOrder(const BinanceSendOrder& from);

  inline BinanceSendOrder& operator=(const BinanceSendOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSendOrder(BinanceSendOrder&& from) noexcept
    : BinanceSendOrder() {
    *this = ::std::move(from);
  }

  inline BinanceSendOrder& operator=(BinanceSendOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceSendOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSendOrder* internal_default_instance() {
    return reinterpret_cast<const BinanceSendOrder*>(
               &_BinanceSendOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(BinanceSendOrder* other);
  friend void swap(BinanceSendOrder& a, BinanceSendOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSendOrder* New() const final {
    return CreateMaybeMessage<BinanceSendOrder>(NULL);
  }

  BinanceSendOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSendOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSendOrder& from);
  void MergeFrom(const BinanceSendOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSendOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BinanceSendOrder_Token Token;
  typedef BinanceSendOrder_Input Input;
  typedef BinanceSendOrder_Output Output;

  // accessors -------------------------------------------------------

  // repeated .TW.proto.BinanceSendOrder.Input inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  ::TW::proto::BinanceSendOrder_Input* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Input >*
      mutable_inputs();
  const ::TW::proto::BinanceSendOrder_Input& inputs(int index) const;
  ::TW::proto::BinanceSendOrder_Input* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Input >&
      inputs() const;

  // repeated .TW.proto.BinanceSendOrder.Output outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  ::TW::proto::BinanceSendOrder_Output* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Output >*
      mutable_outputs();
  const ::TW::proto::BinanceSendOrder_Output& outputs(int index) const;
  ::TW::proto::BinanceSendOrder_Output* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Output >&
      outputs() const;

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceSendOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Input > inputs_;
  ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Output > outputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceTokenFreezeOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceTokenFreezeOrder) */ {
 public:
  BinanceTokenFreezeOrder();
  virtual ~BinanceTokenFreezeOrder();

  BinanceTokenFreezeOrder(const BinanceTokenFreezeOrder& from);

  inline BinanceTokenFreezeOrder& operator=(const BinanceTokenFreezeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTokenFreezeOrder(BinanceTokenFreezeOrder&& from) noexcept
    : BinanceTokenFreezeOrder() {
    *this = ::std::move(from);
  }

  inline BinanceTokenFreezeOrder& operator=(BinanceTokenFreezeOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceTokenFreezeOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTokenFreezeOrder* internal_default_instance() {
    return reinterpret_cast<const BinanceTokenFreezeOrder*>(
               &_BinanceTokenFreezeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(BinanceTokenFreezeOrder* other);
  friend void swap(BinanceTokenFreezeOrder& a, BinanceTokenFreezeOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTokenFreezeOrder* New() const final {
    return CreateMaybeMessage<BinanceTokenFreezeOrder>(NULL);
  }

  BinanceTokenFreezeOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTokenFreezeOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTokenFreezeOrder& from);
  void MergeFrom(const BinanceTokenFreezeOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTokenFreezeOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const void* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string symbol = 2;
  void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // int64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceTokenFreezeOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceTokenUnfreezeOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceTokenUnfreezeOrder) */ {
 public:
  BinanceTokenUnfreezeOrder();
  virtual ~BinanceTokenUnfreezeOrder();

  BinanceTokenUnfreezeOrder(const BinanceTokenUnfreezeOrder& from);

  inline BinanceTokenUnfreezeOrder& operator=(const BinanceTokenUnfreezeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceTokenUnfreezeOrder(BinanceTokenUnfreezeOrder&& from) noexcept
    : BinanceTokenUnfreezeOrder() {
    *this = ::std::move(from);
  }

  inline BinanceTokenUnfreezeOrder& operator=(BinanceTokenUnfreezeOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceTokenUnfreezeOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceTokenUnfreezeOrder* internal_default_instance() {
    return reinterpret_cast<const BinanceTokenUnfreezeOrder*>(
               &_BinanceTokenUnfreezeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(BinanceTokenUnfreezeOrder* other);
  friend void swap(BinanceTokenUnfreezeOrder& a, BinanceTokenUnfreezeOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceTokenUnfreezeOrder* New() const final {
    return CreateMaybeMessage<BinanceTokenUnfreezeOrder>(NULL);
  }

  BinanceTokenUnfreezeOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceTokenUnfreezeOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceTokenUnfreezeOrder& from);
  void MergeFrom(const BinanceTokenUnfreezeOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceTokenUnfreezeOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const void* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string symbol = 2;
  void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // int64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TW.proto.BinanceTokenUnfreezeOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinanceSigningInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TW.proto.BinanceSigningInput) */ {
 public:
  BinanceSigningInput();
  virtual ~BinanceSigningInput();

  BinanceSigningInput(const BinanceSigningInput& from);

  inline BinanceSigningInput& operator=(const BinanceSigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinanceSigningInput(BinanceSigningInput&& from) noexcept
    : BinanceSigningInput() {
    *this = ::std::move(from);
  }

  inline BinanceSigningInput& operator=(BinanceSigningInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinanceSigningInput& default_instance();

  enum OrderOneofCase {
    kTradeOrder = 7,
    kCancelTradeOrder = 8,
    kSendOrder = 9,
    kFreezeOrder = 10,
    kUnfreezeOrder = 11,
    ORDER_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinanceSigningInput* internal_default_instance() {
    return reinterpret_cast<const BinanceSigningInput*>(
               &_BinanceSigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(BinanceSigningInput* other);
  friend void swap(BinanceSigningInput& a, BinanceSigningInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinanceSigningInput* New() const final {
    return CreateMaybeMessage<BinanceSigningInput>(NULL);
  }

  BinanceSigningInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinanceSigningInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinanceSigningInput& from);
  void MergeFrom(const BinanceSigningInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinanceSigningInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chain_id = 1;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 1;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const char* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // string memo = 5;
  void clear_memo();
  static const int kMemoFieldNumber = 5;
  const ::std::string& memo() const;
  void set_memo(const ::std::string& value);
  #if LANG_CXX11
  void set_memo(::std::string&& value);
  #endif
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  ::std::string* mutable_memo();
  ::std::string* release_memo();
  void set_allocated_memo(::std::string* memo);

  // bytes private_key = 6;
  void clear_private_key();
  static const int kPrivateKeyFieldNumber = 6;
  const ::std::string& private_key() const;
  void set_private_key(const ::std::string& value);
  #if LANG_CXX11
  void set_private_key(::std::string&& value);
  #endif
  void set_private_key(const char* value);
  void set_private_key(const void* value, size_t size);
  ::std::string* mutable_private_key();
  ::std::string* release_private_key();
  void set_allocated_private_key(::std::string* private_key);

  // int64 account_number = 2;
  void clear_account_number();
  static const int kAccountNumberFieldNumber = 2;
  ::google::protobuf::int64 account_number() const;
  void set_account_number(::google::protobuf::int64 value);

  // int64 sequence = 3;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // int64 source = 4;
  void clear_source();
  static const int kSourceFieldNumber = 4;
  ::google::protobuf::int64 source() const;
  void set_source(::google::protobuf::int64 value);

  // .TW.proto.BinanceTradeOrder trade_order = 7;
  bool has_trade_order() const;
  void clear_trade_order();
  static const int kTradeOrderFieldNumber = 7;
  private:
  const ::TW::proto::BinanceTradeOrder& _internal_trade_order() const;
  public:
  const ::TW::proto::BinanceTradeOrder& trade_order() const;
  ::TW::proto::BinanceTradeOrder* release_trade_order();
  ::TW::proto::BinanceTradeOrder* mutable_trade_order();
  void set_allocated_trade_order(::TW::proto::BinanceTradeOrder* trade_order);

  // .TW.proto.BinanceCancelTradeOrder cancel_trade_order = 8;
  bool has_cancel_trade_order() const;
  void clear_cancel_trade_order();
  static const int kCancelTradeOrderFieldNumber = 8;
  private:
  const ::TW::proto::BinanceCancelTradeOrder& _internal_cancel_trade_order() const;
  public:
  const ::TW::proto::BinanceCancelTradeOrder& cancel_trade_order() const;
  ::TW::proto::BinanceCancelTradeOrder* release_cancel_trade_order();
  ::TW::proto::BinanceCancelTradeOrder* mutable_cancel_trade_order();
  void set_allocated_cancel_trade_order(::TW::proto::BinanceCancelTradeOrder* cancel_trade_order);

  // .TW.proto.BinanceSendOrder send_order = 9;
  bool has_send_order() const;
  void clear_send_order();
  static const int kSendOrderFieldNumber = 9;
  private:
  const ::TW::proto::BinanceSendOrder& _internal_send_order() const;
  public:
  const ::TW::proto::BinanceSendOrder& send_order() const;
  ::TW::proto::BinanceSendOrder* release_send_order();
  ::TW::proto::BinanceSendOrder* mutable_send_order();
  void set_allocated_send_order(::TW::proto::BinanceSendOrder* send_order);

  // .TW.proto.BinanceTokenFreezeOrder freeze_order = 10;
  bool has_freeze_order() const;
  void clear_freeze_order();
  static const int kFreezeOrderFieldNumber = 10;
  private:
  const ::TW::proto::BinanceTokenFreezeOrder& _internal_freeze_order() const;
  public:
  const ::TW::proto::BinanceTokenFreezeOrder& freeze_order() const;
  ::TW::proto::BinanceTokenFreezeOrder* release_freeze_order();
  ::TW::proto::BinanceTokenFreezeOrder* mutable_freeze_order();
  void set_allocated_freeze_order(::TW::proto::BinanceTokenFreezeOrder* freeze_order);

  // .TW.proto.BinanceTokenUnfreezeOrder unfreeze_order = 11;
  bool has_unfreeze_order() const;
  void clear_unfreeze_order();
  static const int kUnfreezeOrderFieldNumber = 11;
  private:
  const ::TW::proto::BinanceTokenUnfreezeOrder& _internal_unfreeze_order() const;
  public:
  const ::TW::proto::BinanceTokenUnfreezeOrder& unfreeze_order() const;
  ::TW::proto::BinanceTokenUnfreezeOrder* release_unfreeze_order();
  ::TW::proto::BinanceTokenUnfreezeOrder* mutable_unfreeze_order();
  void set_allocated_unfreeze_order(::TW::proto::BinanceTokenUnfreezeOrder* unfreeze_order);

  void clear_order_oneof();
  OrderOneofCase order_oneof_case() const;
  // @@protoc_insertion_point(class_scope:TW.proto.BinanceSigningInput)
 private:
  void set_has_trade_order();
  void set_has_cancel_trade_order();
  void set_has_send_order();
  void set_has_freeze_order();
  void set_has_unfreeze_order();

  inline bool has_order_oneof() const;
  inline void clear_has_order_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::google::protobuf::internal::ArenaStringPtr memo_;
  ::google::protobuf::internal::ArenaStringPtr private_key_;
  ::google::protobuf::int64 account_number_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 source_;
  union OrderOneofUnion {
    OrderOneofUnion() {}
    ::TW::proto::BinanceTradeOrder* trade_order_;
    ::TW::proto::BinanceCancelTradeOrder* cancel_trade_order_;
    ::TW::proto::BinanceSendOrder* send_order_;
    ::TW::proto::BinanceTokenFreezeOrder* freeze_order_;
    ::TW::proto::BinanceTokenUnfreezeOrder* unfreeze_order_;
  } order_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_TrustWalletCore_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BitcoinOutPoint

// bytes hash = 1;
inline void BitcoinOutPoint::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BitcoinOutPoint::hash() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinOutPoint.hash)
  return hash_.GetNoArena();
}
inline void BitcoinOutPoint::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinOutPoint.hash)
}
#if LANG_CXX11
inline void BitcoinOutPoint::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BitcoinOutPoint.hash)
}
#endif
inline void BitcoinOutPoint::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BitcoinOutPoint.hash)
}
inline void BitcoinOutPoint::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BitcoinOutPoint.hash)
}
inline ::std::string* BitcoinOutPoint::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BitcoinOutPoint.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinOutPoint::release_hash() {
  // @@protoc_insertion_point(field_release:TW.proto.BitcoinOutPoint.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinOutPoint::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BitcoinOutPoint.hash)
}

// uint32 index = 2;
inline void BitcoinOutPoint::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 BitcoinOutPoint::index() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinOutPoint.index)
  return index_;
}
inline void BitcoinOutPoint::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinOutPoint.index)
}

// uint32 sequence = 3;
inline void BitcoinOutPoint::clear_sequence() {
  sequence_ = 0u;
}
inline ::google::protobuf::uint32 BitcoinOutPoint::sequence() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinOutPoint.sequence)
  return sequence_;
}
inline void BitcoinOutPoint::set_sequence(::google::protobuf::uint32 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinOutPoint.sequence)
}

// -------------------------------------------------------------------

// BitcoinUnspentTransaction

// .TW.proto.BitcoinOutPoint out_point = 1;
inline bool BitcoinUnspentTransaction::has_out_point() const {
  return this != internal_default_instance() && out_point_ != NULL;
}
inline void BitcoinUnspentTransaction::clear_out_point() {
  if (GetArenaNoVirtual() == NULL && out_point_ != NULL) {
    delete out_point_;
  }
  out_point_ = NULL;
}
inline const ::TW::proto::BitcoinOutPoint& BitcoinUnspentTransaction::_internal_out_point() const {
  return *out_point_;
}
inline const ::TW::proto::BitcoinOutPoint& BitcoinUnspentTransaction::out_point() const {
  const ::TW::proto::BitcoinOutPoint* p = out_point_;
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinUnspentTransaction.out_point)
  return p != NULL ? *p : *reinterpret_cast<const ::TW::proto::BitcoinOutPoint*>(
      &::TW::proto::_BitcoinOutPoint_default_instance_);
}
inline ::TW::proto::BitcoinOutPoint* BitcoinUnspentTransaction::release_out_point() {
  // @@protoc_insertion_point(field_release:TW.proto.BitcoinUnspentTransaction.out_point)
  
  ::TW::proto::BitcoinOutPoint* temp = out_point_;
  out_point_ = NULL;
  return temp;
}
inline ::TW::proto::BitcoinOutPoint* BitcoinUnspentTransaction::mutable_out_point() {
  
  if (out_point_ == NULL) {
    auto* p = CreateMaybeMessage<::TW::proto::BitcoinOutPoint>(GetArenaNoVirtual());
    out_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TW.proto.BitcoinUnspentTransaction.out_point)
  return out_point_;
}
inline void BitcoinUnspentTransaction::set_allocated_out_point(::TW::proto::BitcoinOutPoint* out_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete out_point_;
  }
  if (out_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      out_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, out_point, submessage_arena);
    }
    
  } else {
    
  }
  out_point_ = out_point;
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BitcoinUnspentTransaction.out_point)
}

// bytes script = 2;
inline void BitcoinUnspentTransaction::clear_script() {
  script_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BitcoinUnspentTransaction::script() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinUnspentTransaction.script)
  return script_.GetNoArena();
}
inline void BitcoinUnspentTransaction::set_script(const ::std::string& value) {
  
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinUnspentTransaction.script)
}
#if LANG_CXX11
inline void BitcoinUnspentTransaction::set_script(::std::string&& value) {
  
  script_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BitcoinUnspentTransaction.script)
}
#endif
inline void BitcoinUnspentTransaction::set_script(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BitcoinUnspentTransaction.script)
}
inline void BitcoinUnspentTransaction::set_script(const void* value, size_t size) {
  
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BitcoinUnspentTransaction.script)
}
inline ::std::string* BitcoinUnspentTransaction::mutable_script() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BitcoinUnspentTransaction.script)
  return script_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinUnspentTransaction::release_script() {
  // @@protoc_insertion_point(field_release:TW.proto.BitcoinUnspentTransaction.script)
  
  return script_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinUnspentTransaction::set_allocated_script(::std::string* script) {
  if (script != NULL) {
    
  } else {
    
  }
  script_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BitcoinUnspentTransaction.script)
}

// int64 amount = 3;
inline void BitcoinUnspentTransaction::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BitcoinUnspentTransaction::amount() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinUnspentTransaction.amount)
  return amount_;
}
inline void BitcoinUnspentTransaction::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinUnspentTransaction.amount)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BitcoinSigningInput

// uint32 hash_type = 1;
inline void BitcoinSigningInput::clear_hash_type() {
  hash_type_ = 0u;
}
inline ::google::protobuf::uint32 BitcoinSigningInput::hash_type() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinSigningInput.hash_type)
  return hash_type_;
}
inline void BitcoinSigningInput::set_hash_type(::google::protobuf::uint32 value) {
  
  hash_type_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinSigningInput.hash_type)
}

// int64 amount = 2;
inline void BitcoinSigningInput::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BitcoinSigningInput::amount() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinSigningInput.amount)
  return amount_;
}
inline void BitcoinSigningInput::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinSigningInput.amount)
}

// int64 byte_fee = 3;
inline void BitcoinSigningInput::clear_byte_fee() {
  byte_fee_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BitcoinSigningInput::byte_fee() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinSigningInput.byte_fee)
  return byte_fee_;
}
inline void BitcoinSigningInput::set_byte_fee(::google::protobuf::int64 value) {
  
  byte_fee_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinSigningInput.byte_fee)
}

// string to_address = 4;
inline void BitcoinSigningInput::clear_to_address() {
  to_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BitcoinSigningInput::to_address() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinSigningInput.to_address)
  return to_address_.GetNoArena();
}
inline void BitcoinSigningInput::set_to_address(const ::std::string& value) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinSigningInput.to_address)
}
#if LANG_CXX11
inline void BitcoinSigningInput::set_to_address(::std::string&& value) {
  
  to_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BitcoinSigningInput.to_address)
}
#endif
inline void BitcoinSigningInput::set_to_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BitcoinSigningInput.to_address)
}
inline void BitcoinSigningInput::set_to_address(const char* value, size_t size) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BitcoinSigningInput.to_address)
}
inline ::std::string* BitcoinSigningInput::mutable_to_address() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BitcoinSigningInput.to_address)
  return to_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinSigningInput::release_to_address() {
  // @@protoc_insertion_point(field_release:TW.proto.BitcoinSigningInput.to_address)
  
  return to_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinSigningInput::set_allocated_to_address(::std::string* to_address) {
  if (to_address != NULL) {
    
  } else {
    
  }
  to_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_address);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BitcoinSigningInput.to_address)
}

// string change_address = 5;
inline void BitcoinSigningInput::clear_change_address() {
  change_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BitcoinSigningInput::change_address() const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinSigningInput.change_address)
  return change_address_.GetNoArena();
}
inline void BitcoinSigningInput::set_change_address(const ::std::string& value) {
  
  change_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinSigningInput.change_address)
}
#if LANG_CXX11
inline void BitcoinSigningInput::set_change_address(::std::string&& value) {
  
  change_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BitcoinSigningInput.change_address)
}
#endif
inline void BitcoinSigningInput::set_change_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  change_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BitcoinSigningInput.change_address)
}
inline void BitcoinSigningInput::set_change_address(const char* value, size_t size) {
  
  change_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BitcoinSigningInput.change_address)
}
inline ::std::string* BitcoinSigningInput::mutable_change_address() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BitcoinSigningInput.change_address)
  return change_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinSigningInput::release_change_address() {
  // @@protoc_insertion_point(field_release:TW.proto.BitcoinSigningInput.change_address)
  
  return change_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinSigningInput::set_allocated_change_address(::std::string* change_address) {
  if (change_address != NULL) {
    
  } else {
    
  }
  change_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), change_address);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BitcoinSigningInput.change_address)
}

// repeated bytes private_key = 10;
inline int BitcoinSigningInput::private_key_size() const {
  return private_key_.size();
}
inline void BitcoinSigningInput::clear_private_key() {
  private_key_.Clear();
}
inline const ::std::string& BitcoinSigningInput::private_key(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinSigningInput.private_key)
  return private_key_.Get(index);
}
inline ::std::string* BitcoinSigningInput::mutable_private_key(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BitcoinSigningInput.private_key)
  return private_key_.Mutable(index);
}
inline void BitcoinSigningInput::set_private_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinSigningInput.private_key)
  private_key_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BitcoinSigningInput::set_private_key(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TW.proto.BitcoinSigningInput.private_key)
  private_key_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BitcoinSigningInput::set_private_key(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  private_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TW.proto.BitcoinSigningInput.private_key)
}
inline void BitcoinSigningInput::set_private_key(int index, const void* value, size_t size) {
  private_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BitcoinSigningInput.private_key)
}
inline ::std::string* BitcoinSigningInput::add_private_key() {
  // @@protoc_insertion_point(field_add_mutable:TW.proto.BitcoinSigningInput.private_key)
  return private_key_.Add();
}
inline void BitcoinSigningInput::add_private_key(const ::std::string& value) {
  private_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TW.proto.BitcoinSigningInput.private_key)
}
#if LANG_CXX11
inline void BitcoinSigningInput::add_private_key(::std::string&& value) {
  private_key_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TW.proto.BitcoinSigningInput.private_key)
}
#endif
inline void BitcoinSigningInput::add_private_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  private_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TW.proto.BitcoinSigningInput.private_key)
}
inline void BitcoinSigningInput::add_private_key(const void* value, size_t size) {
  private_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TW.proto.BitcoinSigningInput.private_key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BitcoinSigningInput::private_key() const {
  // @@protoc_insertion_point(field_list:TW.proto.BitcoinSigningInput.private_key)
  return private_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BitcoinSigningInput::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BitcoinSigningInput.private_key)
  return &private_key_;
}

// map<string, bytes> scripts = 11;
inline int BitcoinSigningInput::scripts_size() const {
  return scripts_.size();
}
inline void BitcoinSigningInput::clear_scripts() {
  scripts_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
BitcoinSigningInput::scripts() const {
  // @@protoc_insertion_point(field_map:TW.proto.BitcoinSigningInput.scripts)
  return scripts_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
BitcoinSigningInput::mutable_scripts() {
  // @@protoc_insertion_point(field_mutable_map:TW.proto.BitcoinSigningInput.scripts)
  return scripts_.MutableMap();
}

// repeated .TW.proto.BitcoinUnspentTransaction utxo = 12;
inline int BitcoinSigningInput::utxo_size() const {
  return utxo_.size();
}
inline void BitcoinSigningInput::clear_utxo() {
  utxo_.Clear();
}
inline ::TW::proto::BitcoinUnspentTransaction* BitcoinSigningInput::mutable_utxo(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BitcoinSigningInput.utxo)
  return utxo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TW::proto::BitcoinUnspentTransaction >*
BitcoinSigningInput::mutable_utxo() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BitcoinSigningInput.utxo)
  return &utxo_;
}
inline const ::TW::proto::BitcoinUnspentTransaction& BitcoinSigningInput::utxo(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BitcoinSigningInput.utxo)
  return utxo_.Get(index);
}
inline ::TW::proto::BitcoinUnspentTransaction* BitcoinSigningInput::add_utxo() {
  // @@protoc_insertion_point(field_add:TW.proto.BitcoinSigningInput.utxo)
  return utxo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TW::proto::BitcoinUnspentTransaction >&
BitcoinSigningInput::utxo() const {
  // @@protoc_insertion_point(field_list:TW.proto.BitcoinSigningInput.utxo)
  return utxo_;
}

// -------------------------------------------------------------------

// BinanceTransaction

// repeated bytes msgs = 1;
inline int BinanceTransaction::msgs_size() const {
  return msgs_.size();
}
inline void BinanceTransaction::clear_msgs() {
  msgs_.Clear();
}
inline const ::std::string& BinanceTransaction::msgs(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTransaction.msgs)
  return msgs_.Get(index);
}
inline ::std::string* BinanceTransaction::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTransaction.msgs)
  return msgs_.Mutable(index);
}
inline void BinanceTransaction::set_msgs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTransaction.msgs)
  msgs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BinanceTransaction::set_msgs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTransaction.msgs)
  msgs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BinanceTransaction::set_msgs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  msgs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTransaction.msgs)
}
inline void BinanceTransaction::set_msgs(int index, const void* value, size_t size) {
  msgs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTransaction.msgs)
}
inline ::std::string* BinanceTransaction::add_msgs() {
  // @@protoc_insertion_point(field_add_mutable:TW.proto.BinanceTransaction.msgs)
  return msgs_.Add();
}
inline void BinanceTransaction::add_msgs(const ::std::string& value) {
  msgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TW.proto.BinanceTransaction.msgs)
}
#if LANG_CXX11
inline void BinanceTransaction::add_msgs(::std::string&& value) {
  msgs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TW.proto.BinanceTransaction.msgs)
}
#endif
inline void BinanceTransaction::add_msgs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  msgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TW.proto.BinanceTransaction.msgs)
}
inline void BinanceTransaction::add_msgs(const void* value, size_t size) {
  msgs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TW.proto.BinanceTransaction.msgs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BinanceTransaction::msgs() const {
  // @@protoc_insertion_point(field_list:TW.proto.BinanceTransaction.msgs)
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BinanceTransaction::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BinanceTransaction.msgs)
  return &msgs_;
}

// repeated bytes signatures = 2;
inline int BinanceTransaction::signatures_size() const {
  return signatures_.size();
}
inline void BinanceTransaction::clear_signatures() {
  signatures_.Clear();
}
inline const ::std::string& BinanceTransaction::signatures(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTransaction.signatures)
  return signatures_.Get(index);
}
inline ::std::string* BinanceTransaction::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTransaction.signatures)
  return signatures_.Mutable(index);
}
inline void BinanceTransaction::set_signatures(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTransaction.signatures)
  signatures_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BinanceTransaction::set_signatures(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTransaction.signatures)
  signatures_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BinanceTransaction::set_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTransaction.signatures)
}
inline void BinanceTransaction::set_signatures(int index, const void* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTransaction.signatures)
}
inline ::std::string* BinanceTransaction::add_signatures() {
  // @@protoc_insertion_point(field_add_mutable:TW.proto.BinanceTransaction.signatures)
  return signatures_.Add();
}
inline void BinanceTransaction::add_signatures(const ::std::string& value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TW.proto.BinanceTransaction.signatures)
}
#if LANG_CXX11
inline void BinanceTransaction::add_signatures(::std::string&& value) {
  signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TW.proto.BinanceTransaction.signatures)
}
#endif
inline void BinanceTransaction::add_signatures(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TW.proto.BinanceTransaction.signatures)
}
inline void BinanceTransaction::add_signatures(const void* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TW.proto.BinanceTransaction.signatures)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BinanceTransaction::signatures() const {
  // @@protoc_insertion_point(field_list:TW.proto.BinanceTransaction.signatures)
  return signatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BinanceTransaction::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BinanceTransaction.signatures)
  return &signatures_;
}

// string memo = 3;
inline void BinanceTransaction::clear_memo() {
  memo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTransaction::memo() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTransaction.memo)
  return memo_.GetNoArena();
}
inline void BinanceTransaction::set_memo(const ::std::string& value) {
  
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTransaction.memo)
}
#if LANG_CXX11
inline void BinanceTransaction::set_memo(::std::string&& value) {
  
  memo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTransaction.memo)
}
#endif
inline void BinanceTransaction::set_memo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTransaction.memo)
}
inline void BinanceTransaction::set_memo(const char* value, size_t size) {
  
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTransaction.memo)
}
inline ::std::string* BinanceTransaction::mutable_memo() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTransaction.memo)
  return memo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTransaction::release_memo() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTransaction.memo)
  
  return memo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTransaction::set_allocated_memo(::std::string* memo) {
  if (memo != NULL) {
    
  } else {
    
  }
  memo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTransaction.memo)
}

// int64 source = 4;
inline void BinanceTransaction::clear_source() {
  source_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTransaction::source() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTransaction.source)
  return source_;
}
inline void BinanceTransaction::set_source(::google::protobuf::int64 value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTransaction.source)
}

// bytes data = 5;
inline void BinanceTransaction::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTransaction::data() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTransaction.data)
  return data_.GetNoArena();
}
inline void BinanceTransaction::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTransaction.data)
}
#if LANG_CXX11
inline void BinanceTransaction::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTransaction.data)
}
#endif
inline void BinanceTransaction::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTransaction.data)
}
inline void BinanceTransaction::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTransaction.data)
}
inline ::std::string* BinanceTransaction::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTransaction.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTransaction::release_data() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTransaction.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTransaction::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTransaction.data)
}

// -------------------------------------------------------------------

// BinanceSignature_PubKey

// -------------------------------------------------------------------

// BinanceSignature

// bytes pub_key = 1;
inline void BinanceSignature::clear_pub_key() {
  pub_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSignature::pub_key() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSignature.pub_key)
  return pub_key_.GetNoArena();
}
inline void BinanceSignature::set_pub_key(const ::std::string& value) {
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSignature.pub_key)
}
#if LANG_CXX11
inline void BinanceSignature::set_pub_key(::std::string&& value) {
  
  pub_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSignature.pub_key)
}
#endif
inline void BinanceSignature::set_pub_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSignature.pub_key)
}
inline void BinanceSignature::set_pub_key(const void* value, size_t size) {
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSignature.pub_key)
}
inline ::std::string* BinanceSignature::mutable_pub_key() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSignature.pub_key)
  return pub_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSignature::release_pub_key() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSignature.pub_key)
  
  return pub_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSignature::set_allocated_pub_key(::std::string* pub_key) {
  if (pub_key != NULL) {
    
  } else {
    
  }
  pub_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pub_key);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSignature.pub_key)
}

// bytes signature = 2;
inline void BinanceSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSignature::signature() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSignature.signature)
  return signature_.GetNoArena();
}
inline void BinanceSignature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSignature.signature)
}
#if LANG_CXX11
inline void BinanceSignature::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSignature.signature)
}
#endif
inline void BinanceSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSignature.signature)
}
inline void BinanceSignature::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSignature.signature)
}
inline ::std::string* BinanceSignature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSignature::release_signature() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSignature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSignature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSignature.signature)
}

// int64 account_number = 3;
inline void BinanceSignature::clear_account_number() {
  account_number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceSignature::account_number() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSignature.account_number)
  return account_number_;
}
inline void BinanceSignature::set_account_number(::google::protobuf::int64 value) {
  
  account_number_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSignature.account_number)
}

// int64 sequence = 4;
inline void BinanceSignature::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceSignature::sequence() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSignature.sequence)
  return sequence_;
}
inline void BinanceSignature::set_sequence(::google::protobuf::int64 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSignature.sequence)
}

// -------------------------------------------------------------------

// BinanceTradeOrder

// bytes sender = 1;
inline void BinanceTradeOrder::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTradeOrder::sender() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.sender)
  return sender_.GetNoArena();
}
inline void BinanceTradeOrder::set_sender(const ::std::string& value) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.sender)
}
#if LANG_CXX11
inline void BinanceTradeOrder::set_sender(::std::string&& value) {
  
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTradeOrder.sender)
}
#endif
inline void BinanceTradeOrder::set_sender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTradeOrder.sender)
}
inline void BinanceTradeOrder::set_sender(const void* value, size_t size) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTradeOrder.sender)
}
inline ::std::string* BinanceTradeOrder::mutable_sender() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTradeOrder.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTradeOrder::release_sender() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTradeOrder.sender)
  
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTradeOrder::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    
  } else {
    
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTradeOrder.sender)
}

// string id = 2;
inline void BinanceTradeOrder::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTradeOrder::id() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.id)
  return id_.GetNoArena();
}
inline void BinanceTradeOrder::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.id)
}
#if LANG_CXX11
inline void BinanceTradeOrder::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTradeOrder.id)
}
#endif
inline void BinanceTradeOrder::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTradeOrder.id)
}
inline void BinanceTradeOrder::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTradeOrder.id)
}
inline ::std::string* BinanceTradeOrder::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTradeOrder.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTradeOrder::release_id() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTradeOrder.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTradeOrder::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTradeOrder.id)
}

// string symbol = 3;
inline void BinanceTradeOrder::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTradeOrder::symbol() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.symbol)
  return symbol_.GetNoArena();
}
inline void BinanceTradeOrder::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.symbol)
}
#if LANG_CXX11
inline void BinanceTradeOrder::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTradeOrder.symbol)
}
#endif
inline void BinanceTradeOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTradeOrder.symbol)
}
inline void BinanceTradeOrder::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTradeOrder.symbol)
}
inline ::std::string* BinanceTradeOrder::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTradeOrder.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTradeOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTradeOrder.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTradeOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTradeOrder.symbol)
}

// int64 ordertype = 4;
inline void BinanceTradeOrder::clear_ordertype() {
  ordertype_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTradeOrder::ordertype() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.ordertype)
  return ordertype_;
}
inline void BinanceTradeOrder::set_ordertype(::google::protobuf::int64 value) {
  
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.ordertype)
}

// int64 side = 5;
inline void BinanceTradeOrder::clear_side() {
  side_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTradeOrder::side() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.side)
  return side_;
}
inline void BinanceTradeOrder::set_side(::google::protobuf::int64 value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.side)
}

// int64 price = 6;
inline void BinanceTradeOrder::clear_price() {
  price_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTradeOrder::price() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.price)
  return price_;
}
inline void BinanceTradeOrder::set_price(::google::protobuf::int64 value) {
  
  price_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.price)
}

// int64 quantity = 7;
inline void BinanceTradeOrder::clear_quantity() {
  quantity_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTradeOrder::quantity() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.quantity)
  return quantity_;
}
inline void BinanceTradeOrder::set_quantity(::google::protobuf::int64 value) {
  
  quantity_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.quantity)
}

// int64 timeinforce = 8;
inline void BinanceTradeOrder::clear_timeinforce() {
  timeinforce_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTradeOrder::timeinforce() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTradeOrder.timeinforce)
  return timeinforce_;
}
inline void BinanceTradeOrder::set_timeinforce(::google::protobuf::int64 value) {
  
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTradeOrder.timeinforce)
}

// -------------------------------------------------------------------

// BinanceCancelTradeOrder

// bytes sender = 1;
inline void BinanceCancelTradeOrder::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceCancelTradeOrder::sender() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceCancelTradeOrder.sender)
  return sender_.GetNoArena();
}
inline void BinanceCancelTradeOrder::set_sender(const ::std::string& value) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceCancelTradeOrder.sender)
}
#if LANG_CXX11
inline void BinanceCancelTradeOrder::set_sender(::std::string&& value) {
  
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceCancelTradeOrder.sender)
}
#endif
inline void BinanceCancelTradeOrder::set_sender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceCancelTradeOrder.sender)
}
inline void BinanceCancelTradeOrder::set_sender(const void* value, size_t size) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceCancelTradeOrder.sender)
}
inline ::std::string* BinanceCancelTradeOrder::mutable_sender() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceCancelTradeOrder.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceCancelTradeOrder::release_sender() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceCancelTradeOrder.sender)
  
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceCancelTradeOrder::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    
  } else {
    
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceCancelTradeOrder.sender)
}

// string symbol = 2;
inline void BinanceCancelTradeOrder::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceCancelTradeOrder::symbol() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceCancelTradeOrder.symbol)
  return symbol_.GetNoArena();
}
inline void BinanceCancelTradeOrder::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceCancelTradeOrder.symbol)
}
#if LANG_CXX11
inline void BinanceCancelTradeOrder::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceCancelTradeOrder.symbol)
}
#endif
inline void BinanceCancelTradeOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceCancelTradeOrder.symbol)
}
inline void BinanceCancelTradeOrder::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceCancelTradeOrder.symbol)
}
inline ::std::string* BinanceCancelTradeOrder::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceCancelTradeOrder.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceCancelTradeOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceCancelTradeOrder.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceCancelTradeOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceCancelTradeOrder.symbol)
}

// string refid = 4;
inline void BinanceCancelTradeOrder::clear_refid() {
  refid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceCancelTradeOrder::refid() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceCancelTradeOrder.refid)
  return refid_.GetNoArena();
}
inline void BinanceCancelTradeOrder::set_refid(const ::std::string& value) {
  
  refid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceCancelTradeOrder.refid)
}
#if LANG_CXX11
inline void BinanceCancelTradeOrder::set_refid(::std::string&& value) {
  
  refid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceCancelTradeOrder.refid)
}
#endif
inline void BinanceCancelTradeOrder::set_refid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  refid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceCancelTradeOrder.refid)
}
inline void BinanceCancelTradeOrder::set_refid(const char* value, size_t size) {
  
  refid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceCancelTradeOrder.refid)
}
inline ::std::string* BinanceCancelTradeOrder::mutable_refid() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceCancelTradeOrder.refid)
  return refid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceCancelTradeOrder::release_refid() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceCancelTradeOrder.refid)
  
  return refid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceCancelTradeOrder::set_allocated_refid(::std::string* refid) {
  if (refid != NULL) {
    
  } else {
    
  }
  refid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refid);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceCancelTradeOrder.refid)
}

// -------------------------------------------------------------------

// BinanceSendOrder_Token

// string denom = 1;
inline void BinanceSendOrder_Token::clear_denom() {
  denom_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSendOrder_Token::denom() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.Token.denom)
  return denom_.GetNoArena();
}
inline void BinanceSendOrder_Token::set_denom(const ::std::string& value) {
  
  denom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSendOrder.Token.denom)
}
#if LANG_CXX11
inline void BinanceSendOrder_Token::set_denom(::std::string&& value) {
  
  denom_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSendOrder.Token.denom)
}
#endif
inline void BinanceSendOrder_Token::set_denom(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  denom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSendOrder.Token.denom)
}
inline void BinanceSendOrder_Token::set_denom(const char* value, size_t size) {
  
  denom_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSendOrder.Token.denom)
}
inline ::std::string* BinanceSendOrder_Token::mutable_denom() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSendOrder.Token.denom)
  return denom_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSendOrder_Token::release_denom() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSendOrder.Token.denom)
  
  return denom_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSendOrder_Token::set_allocated_denom(::std::string* denom) {
  if (denom != NULL) {
    
  } else {
    
  }
  denom_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), denom);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSendOrder.Token.denom)
}

// int64 amount = 2;
inline void BinanceSendOrder_Token::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceSendOrder_Token::amount() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.Token.amount)
  return amount_;
}
inline void BinanceSendOrder_Token::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSendOrder.Token.amount)
}

// -------------------------------------------------------------------

// BinanceSendOrder_Input

// bytes address = 1;
inline void BinanceSendOrder_Input::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSendOrder_Input::address() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.Input.address)
  return address_.GetNoArena();
}
inline void BinanceSendOrder_Input::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSendOrder.Input.address)
}
#if LANG_CXX11
inline void BinanceSendOrder_Input::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSendOrder.Input.address)
}
#endif
inline void BinanceSendOrder_Input::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSendOrder.Input.address)
}
inline void BinanceSendOrder_Input::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSendOrder.Input.address)
}
inline ::std::string* BinanceSendOrder_Input::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSendOrder.Input.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSendOrder_Input::release_address() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSendOrder.Input.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSendOrder_Input::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSendOrder.Input.address)
}

// repeated .TW.proto.BinanceSendOrder.Token coins = 2;
inline int BinanceSendOrder_Input::coins_size() const {
  return coins_.size();
}
inline void BinanceSendOrder_Input::clear_coins() {
  coins_.Clear();
}
inline ::TW::proto::BinanceSendOrder_Token* BinanceSendOrder_Input::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSendOrder.Input.coins)
  return coins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >*
BinanceSendOrder_Input::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BinanceSendOrder.Input.coins)
  return &coins_;
}
inline const ::TW::proto::BinanceSendOrder_Token& BinanceSendOrder_Input::coins(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.Input.coins)
  return coins_.Get(index);
}
inline ::TW::proto::BinanceSendOrder_Token* BinanceSendOrder_Input::add_coins() {
  // @@protoc_insertion_point(field_add:TW.proto.BinanceSendOrder.Input.coins)
  return coins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >&
BinanceSendOrder_Input::coins() const {
  // @@protoc_insertion_point(field_list:TW.proto.BinanceSendOrder.Input.coins)
  return coins_;
}

// -------------------------------------------------------------------

// BinanceSendOrder_Output

// bytes address = 1;
inline void BinanceSendOrder_Output::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSendOrder_Output::address() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.Output.address)
  return address_.GetNoArena();
}
inline void BinanceSendOrder_Output::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSendOrder.Output.address)
}
#if LANG_CXX11
inline void BinanceSendOrder_Output::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSendOrder.Output.address)
}
#endif
inline void BinanceSendOrder_Output::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSendOrder.Output.address)
}
inline void BinanceSendOrder_Output::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSendOrder.Output.address)
}
inline ::std::string* BinanceSendOrder_Output::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSendOrder.Output.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSendOrder_Output::release_address() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSendOrder.Output.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSendOrder_Output::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSendOrder.Output.address)
}

// repeated .TW.proto.BinanceSendOrder.Token coins = 2;
inline int BinanceSendOrder_Output::coins_size() const {
  return coins_.size();
}
inline void BinanceSendOrder_Output::clear_coins() {
  coins_.Clear();
}
inline ::TW::proto::BinanceSendOrder_Token* BinanceSendOrder_Output::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSendOrder.Output.coins)
  return coins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >*
BinanceSendOrder_Output::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BinanceSendOrder.Output.coins)
  return &coins_;
}
inline const ::TW::proto::BinanceSendOrder_Token& BinanceSendOrder_Output::coins(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.Output.coins)
  return coins_.Get(index);
}
inline ::TW::proto::BinanceSendOrder_Token* BinanceSendOrder_Output::add_coins() {
  // @@protoc_insertion_point(field_add:TW.proto.BinanceSendOrder.Output.coins)
  return coins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Token >&
BinanceSendOrder_Output::coins() const {
  // @@protoc_insertion_point(field_list:TW.proto.BinanceSendOrder.Output.coins)
  return coins_;
}

// -------------------------------------------------------------------

// BinanceSendOrder

// repeated .TW.proto.BinanceSendOrder.Input inputs = 1;
inline int BinanceSendOrder::inputs_size() const {
  return inputs_.size();
}
inline void BinanceSendOrder::clear_inputs() {
  inputs_.Clear();
}
inline ::TW::proto::BinanceSendOrder_Input* BinanceSendOrder::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSendOrder.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Input >*
BinanceSendOrder::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BinanceSendOrder.inputs)
  return &inputs_;
}
inline const ::TW::proto::BinanceSendOrder_Input& BinanceSendOrder::inputs(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.inputs)
  return inputs_.Get(index);
}
inline ::TW::proto::BinanceSendOrder_Input* BinanceSendOrder::add_inputs() {
  // @@protoc_insertion_point(field_add:TW.proto.BinanceSendOrder.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Input >&
BinanceSendOrder::inputs() const {
  // @@protoc_insertion_point(field_list:TW.proto.BinanceSendOrder.inputs)
  return inputs_;
}

// repeated .TW.proto.BinanceSendOrder.Output outputs = 2;
inline int BinanceSendOrder::outputs_size() const {
  return outputs_.size();
}
inline void BinanceSendOrder::clear_outputs() {
  outputs_.Clear();
}
inline ::TW::proto::BinanceSendOrder_Output* BinanceSendOrder::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSendOrder.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Output >*
BinanceSendOrder::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TW.proto.BinanceSendOrder.outputs)
  return &outputs_;
}
inline const ::TW::proto::BinanceSendOrder_Output& BinanceSendOrder::outputs(int index) const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSendOrder.outputs)
  return outputs_.Get(index);
}
inline ::TW::proto::BinanceSendOrder_Output* BinanceSendOrder::add_outputs() {
  // @@protoc_insertion_point(field_add:TW.proto.BinanceSendOrder.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TW::proto::BinanceSendOrder_Output >&
BinanceSendOrder::outputs() const {
  // @@protoc_insertion_point(field_list:TW.proto.BinanceSendOrder.outputs)
  return outputs_;
}

// -------------------------------------------------------------------

// BinanceTokenFreezeOrder

// bytes from = 1;
inline void BinanceTokenFreezeOrder::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTokenFreezeOrder::from() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTokenFreezeOrder.from)
  return from_.GetNoArena();
}
inline void BinanceTokenFreezeOrder::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTokenFreezeOrder.from)
}
#if LANG_CXX11
inline void BinanceTokenFreezeOrder::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTokenFreezeOrder.from)
}
#endif
inline void BinanceTokenFreezeOrder::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTokenFreezeOrder.from)
}
inline void BinanceTokenFreezeOrder::set_from(const void* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTokenFreezeOrder.from)
}
inline ::std::string* BinanceTokenFreezeOrder::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTokenFreezeOrder.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTokenFreezeOrder::release_from() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTokenFreezeOrder.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTokenFreezeOrder::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTokenFreezeOrder.from)
}

// string symbol = 2;
inline void BinanceTokenFreezeOrder::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTokenFreezeOrder::symbol() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTokenFreezeOrder.symbol)
  return symbol_.GetNoArena();
}
inline void BinanceTokenFreezeOrder::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTokenFreezeOrder.symbol)
}
#if LANG_CXX11
inline void BinanceTokenFreezeOrder::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTokenFreezeOrder.symbol)
}
#endif
inline void BinanceTokenFreezeOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTokenFreezeOrder.symbol)
}
inline void BinanceTokenFreezeOrder::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTokenFreezeOrder.symbol)
}
inline ::std::string* BinanceTokenFreezeOrder::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTokenFreezeOrder.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTokenFreezeOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTokenFreezeOrder.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTokenFreezeOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTokenFreezeOrder.symbol)
}

// int64 amount = 3;
inline void BinanceTokenFreezeOrder::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTokenFreezeOrder::amount() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTokenFreezeOrder.amount)
  return amount_;
}
inline void BinanceTokenFreezeOrder::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTokenFreezeOrder.amount)
}

// -------------------------------------------------------------------

// BinanceTokenUnfreezeOrder

// bytes from = 1;
inline void BinanceTokenUnfreezeOrder::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTokenUnfreezeOrder::from() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTokenUnfreezeOrder.from)
  return from_.GetNoArena();
}
inline void BinanceTokenUnfreezeOrder::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTokenUnfreezeOrder.from)
}
#if LANG_CXX11
inline void BinanceTokenUnfreezeOrder::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTokenUnfreezeOrder.from)
}
#endif
inline void BinanceTokenUnfreezeOrder::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTokenUnfreezeOrder.from)
}
inline void BinanceTokenUnfreezeOrder::set_from(const void* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTokenUnfreezeOrder.from)
}
inline ::std::string* BinanceTokenUnfreezeOrder::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTokenUnfreezeOrder.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTokenUnfreezeOrder::release_from() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTokenUnfreezeOrder.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTokenUnfreezeOrder::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTokenUnfreezeOrder.from)
}

// string symbol = 2;
inline void BinanceTokenUnfreezeOrder::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceTokenUnfreezeOrder::symbol() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTokenUnfreezeOrder.symbol)
  return symbol_.GetNoArena();
}
inline void BinanceTokenUnfreezeOrder::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTokenUnfreezeOrder.symbol)
}
#if LANG_CXX11
inline void BinanceTokenUnfreezeOrder::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceTokenUnfreezeOrder.symbol)
}
#endif
inline void BinanceTokenUnfreezeOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceTokenUnfreezeOrder.symbol)
}
inline void BinanceTokenUnfreezeOrder::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceTokenUnfreezeOrder.symbol)
}
inline ::std::string* BinanceTokenUnfreezeOrder::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceTokenUnfreezeOrder.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceTokenUnfreezeOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceTokenUnfreezeOrder.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceTokenUnfreezeOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceTokenUnfreezeOrder.symbol)
}

// int64 amount = 3;
inline void BinanceTokenUnfreezeOrder::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceTokenUnfreezeOrder::amount() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceTokenUnfreezeOrder.amount)
  return amount_;
}
inline void BinanceTokenUnfreezeOrder::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceTokenUnfreezeOrder.amount)
}

// -------------------------------------------------------------------

// BinanceSigningInput

// string chain_id = 1;
inline void BinanceSigningInput::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSigningInput::chain_id() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.chain_id)
  return chain_id_.GetNoArena();
}
inline void BinanceSigningInput::set_chain_id(const ::std::string& value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSigningInput.chain_id)
}
#if LANG_CXX11
inline void BinanceSigningInput::set_chain_id(::std::string&& value) {
  
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSigningInput.chain_id)
}
#endif
inline void BinanceSigningInput::set_chain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSigningInput.chain_id)
}
inline void BinanceSigningInput::set_chain_id(const char* value, size_t size) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSigningInput.chain_id)
}
inline ::std::string* BinanceSigningInput::mutable_chain_id() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSigningInput::release_chain_id() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.chain_id)
  
  return chain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSigningInput::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != NULL) {
    
  } else {
    
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSigningInput.chain_id)
}

// int64 account_number = 2;
inline void BinanceSigningInput::clear_account_number() {
  account_number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceSigningInput::account_number() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.account_number)
  return account_number_;
}
inline void BinanceSigningInput::set_account_number(::google::protobuf::int64 value) {
  
  account_number_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSigningInput.account_number)
}

// int64 sequence = 3;
inline void BinanceSigningInput::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceSigningInput::sequence() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.sequence)
  return sequence_;
}
inline void BinanceSigningInput::set_sequence(::google::protobuf::int64 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSigningInput.sequence)
}

// int64 source = 4;
inline void BinanceSigningInput::clear_source() {
  source_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BinanceSigningInput::source() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.source)
  return source_;
}
inline void BinanceSigningInput::set_source(::google::protobuf::int64 value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSigningInput.source)
}

// string memo = 5;
inline void BinanceSigningInput::clear_memo() {
  memo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSigningInput::memo() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.memo)
  return memo_.GetNoArena();
}
inline void BinanceSigningInput::set_memo(const ::std::string& value) {
  
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSigningInput.memo)
}
#if LANG_CXX11
inline void BinanceSigningInput::set_memo(::std::string&& value) {
  
  memo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSigningInput.memo)
}
#endif
inline void BinanceSigningInput::set_memo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSigningInput.memo)
}
inline void BinanceSigningInput::set_memo(const char* value, size_t size) {
  
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSigningInput.memo)
}
inline ::std::string* BinanceSigningInput::mutable_memo() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.memo)
  return memo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSigningInput::release_memo() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.memo)
  
  return memo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSigningInput::set_allocated_memo(::std::string* memo) {
  if (memo != NULL) {
    
  } else {
    
  }
  memo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSigningInput.memo)
}

// bytes private_key = 6;
inline void BinanceSigningInput::clear_private_key() {
  private_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinanceSigningInput::private_key() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.private_key)
  return private_key_.GetNoArena();
}
inline void BinanceSigningInput::set_private_key(const ::std::string& value) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TW.proto.BinanceSigningInput.private_key)
}
#if LANG_CXX11
inline void BinanceSigningInput::set_private_key(::std::string&& value) {
  
  private_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TW.proto.BinanceSigningInput.private_key)
}
#endif
inline void BinanceSigningInput::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TW.proto.BinanceSigningInput.private_key)
}
inline void BinanceSigningInput::set_private_key(const void* value, size_t size) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TW.proto.BinanceSigningInput.private_key)
}
inline ::std::string* BinanceSigningInput::mutable_private_key() {
  
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.private_key)
  return private_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinanceSigningInput::release_private_key() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.private_key)
  
  return private_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinanceSigningInput::set_allocated_private_key(::std::string* private_key) {
  if (private_key != NULL) {
    
  } else {
    
  }
  private_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), private_key);
  // @@protoc_insertion_point(field_set_allocated:TW.proto.BinanceSigningInput.private_key)
}

// .TW.proto.BinanceTradeOrder trade_order = 7;
inline bool BinanceSigningInput::has_trade_order() const {
  return order_oneof_case() == kTradeOrder;
}
inline void BinanceSigningInput::set_has_trade_order() {
  _oneof_case_[0] = kTradeOrder;
}
inline void BinanceSigningInput::clear_trade_order() {
  if (has_trade_order()) {
    delete order_oneof_.trade_order_;
    clear_has_order_oneof();
  }
}
inline const ::TW::proto::BinanceTradeOrder& BinanceSigningInput::_internal_trade_order() const {
  return *order_oneof_.trade_order_;
}
inline ::TW::proto::BinanceTradeOrder* BinanceSigningInput::release_trade_order() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.trade_order)
  if (has_trade_order()) {
    clear_has_order_oneof();
      ::TW::proto::BinanceTradeOrder* temp = order_oneof_.trade_order_;
    order_oneof_.trade_order_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TW::proto::BinanceTradeOrder& BinanceSigningInput::trade_order() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.trade_order)
  return has_trade_order()
      ? *order_oneof_.trade_order_
      : *reinterpret_cast< ::TW::proto::BinanceTradeOrder*>(&::TW::proto::_BinanceTradeOrder_default_instance_);
}
inline ::TW::proto::BinanceTradeOrder* BinanceSigningInput::mutable_trade_order() {
  if (!has_trade_order()) {
    clear_order_oneof();
    set_has_trade_order();
    order_oneof_.trade_order_ = CreateMaybeMessage< ::TW::proto::BinanceTradeOrder >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.trade_order)
  return order_oneof_.trade_order_;
}

// .TW.proto.BinanceCancelTradeOrder cancel_trade_order = 8;
inline bool BinanceSigningInput::has_cancel_trade_order() const {
  return order_oneof_case() == kCancelTradeOrder;
}
inline void BinanceSigningInput::set_has_cancel_trade_order() {
  _oneof_case_[0] = kCancelTradeOrder;
}
inline void BinanceSigningInput::clear_cancel_trade_order() {
  if (has_cancel_trade_order()) {
    delete order_oneof_.cancel_trade_order_;
    clear_has_order_oneof();
  }
}
inline const ::TW::proto::BinanceCancelTradeOrder& BinanceSigningInput::_internal_cancel_trade_order() const {
  return *order_oneof_.cancel_trade_order_;
}
inline ::TW::proto::BinanceCancelTradeOrder* BinanceSigningInput::release_cancel_trade_order() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.cancel_trade_order)
  if (has_cancel_trade_order()) {
    clear_has_order_oneof();
      ::TW::proto::BinanceCancelTradeOrder* temp = order_oneof_.cancel_trade_order_;
    order_oneof_.cancel_trade_order_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TW::proto::BinanceCancelTradeOrder& BinanceSigningInput::cancel_trade_order() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.cancel_trade_order)
  return has_cancel_trade_order()
      ? *order_oneof_.cancel_trade_order_
      : *reinterpret_cast< ::TW::proto::BinanceCancelTradeOrder*>(&::TW::proto::_BinanceCancelTradeOrder_default_instance_);
}
inline ::TW::proto::BinanceCancelTradeOrder* BinanceSigningInput::mutable_cancel_trade_order() {
  if (!has_cancel_trade_order()) {
    clear_order_oneof();
    set_has_cancel_trade_order();
    order_oneof_.cancel_trade_order_ = CreateMaybeMessage< ::TW::proto::BinanceCancelTradeOrder >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.cancel_trade_order)
  return order_oneof_.cancel_trade_order_;
}

// .TW.proto.BinanceSendOrder send_order = 9;
inline bool BinanceSigningInput::has_send_order() const {
  return order_oneof_case() == kSendOrder;
}
inline void BinanceSigningInput::set_has_send_order() {
  _oneof_case_[0] = kSendOrder;
}
inline void BinanceSigningInput::clear_send_order() {
  if (has_send_order()) {
    delete order_oneof_.send_order_;
    clear_has_order_oneof();
  }
}
inline const ::TW::proto::BinanceSendOrder& BinanceSigningInput::_internal_send_order() const {
  return *order_oneof_.send_order_;
}
inline ::TW::proto::BinanceSendOrder* BinanceSigningInput::release_send_order() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.send_order)
  if (has_send_order()) {
    clear_has_order_oneof();
      ::TW::proto::BinanceSendOrder* temp = order_oneof_.send_order_;
    order_oneof_.send_order_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TW::proto::BinanceSendOrder& BinanceSigningInput::send_order() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.send_order)
  return has_send_order()
      ? *order_oneof_.send_order_
      : *reinterpret_cast< ::TW::proto::BinanceSendOrder*>(&::TW::proto::_BinanceSendOrder_default_instance_);
}
inline ::TW::proto::BinanceSendOrder* BinanceSigningInput::mutable_send_order() {
  if (!has_send_order()) {
    clear_order_oneof();
    set_has_send_order();
    order_oneof_.send_order_ = CreateMaybeMessage< ::TW::proto::BinanceSendOrder >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.send_order)
  return order_oneof_.send_order_;
}

// .TW.proto.BinanceTokenFreezeOrder freeze_order = 10;
inline bool BinanceSigningInput::has_freeze_order() const {
  return order_oneof_case() == kFreezeOrder;
}
inline void BinanceSigningInput::set_has_freeze_order() {
  _oneof_case_[0] = kFreezeOrder;
}
inline void BinanceSigningInput::clear_freeze_order() {
  if (has_freeze_order()) {
    delete order_oneof_.freeze_order_;
    clear_has_order_oneof();
  }
}
inline const ::TW::proto::BinanceTokenFreezeOrder& BinanceSigningInput::_internal_freeze_order() const {
  return *order_oneof_.freeze_order_;
}
inline ::TW::proto::BinanceTokenFreezeOrder* BinanceSigningInput::release_freeze_order() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.freeze_order)
  if (has_freeze_order()) {
    clear_has_order_oneof();
      ::TW::proto::BinanceTokenFreezeOrder* temp = order_oneof_.freeze_order_;
    order_oneof_.freeze_order_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TW::proto::BinanceTokenFreezeOrder& BinanceSigningInput::freeze_order() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.freeze_order)
  return has_freeze_order()
      ? *order_oneof_.freeze_order_
      : *reinterpret_cast< ::TW::proto::BinanceTokenFreezeOrder*>(&::TW::proto::_BinanceTokenFreezeOrder_default_instance_);
}
inline ::TW::proto::BinanceTokenFreezeOrder* BinanceSigningInput::mutable_freeze_order() {
  if (!has_freeze_order()) {
    clear_order_oneof();
    set_has_freeze_order();
    order_oneof_.freeze_order_ = CreateMaybeMessage< ::TW::proto::BinanceTokenFreezeOrder >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.freeze_order)
  return order_oneof_.freeze_order_;
}

// .TW.proto.BinanceTokenUnfreezeOrder unfreeze_order = 11;
inline bool BinanceSigningInput::has_unfreeze_order() const {
  return order_oneof_case() == kUnfreezeOrder;
}
inline void BinanceSigningInput::set_has_unfreeze_order() {
  _oneof_case_[0] = kUnfreezeOrder;
}
inline void BinanceSigningInput::clear_unfreeze_order() {
  if (has_unfreeze_order()) {
    delete order_oneof_.unfreeze_order_;
    clear_has_order_oneof();
  }
}
inline const ::TW::proto::BinanceTokenUnfreezeOrder& BinanceSigningInput::_internal_unfreeze_order() const {
  return *order_oneof_.unfreeze_order_;
}
inline ::TW::proto::BinanceTokenUnfreezeOrder* BinanceSigningInput::release_unfreeze_order() {
  // @@protoc_insertion_point(field_release:TW.proto.BinanceSigningInput.unfreeze_order)
  if (has_unfreeze_order()) {
    clear_has_order_oneof();
      ::TW::proto::BinanceTokenUnfreezeOrder* temp = order_oneof_.unfreeze_order_;
    order_oneof_.unfreeze_order_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TW::proto::BinanceTokenUnfreezeOrder& BinanceSigningInput::unfreeze_order() const {
  // @@protoc_insertion_point(field_get:TW.proto.BinanceSigningInput.unfreeze_order)
  return has_unfreeze_order()
      ? *order_oneof_.unfreeze_order_
      : *reinterpret_cast< ::TW::proto::BinanceTokenUnfreezeOrder*>(&::TW::proto::_BinanceTokenUnfreezeOrder_default_instance_);
}
inline ::TW::proto::BinanceTokenUnfreezeOrder* BinanceSigningInput::mutable_unfreeze_order() {
  if (!has_unfreeze_order()) {
    clear_order_oneof();
    set_has_unfreeze_order();
    order_oneof_.unfreeze_order_ = CreateMaybeMessage< ::TW::proto::BinanceTokenUnfreezeOrder >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TW.proto.BinanceSigningInput.unfreeze_order)
  return order_oneof_.unfreeze_order_;
}

inline bool BinanceSigningInput::has_order_oneof() const {
  return order_oneof_case() != ORDER_ONEOF_NOT_SET;
}
inline void BinanceSigningInput::clear_has_order_oneof() {
  _oneof_case_[0] = ORDER_ONEOF_NOT_SET;
}
inline BinanceSigningInput::OrderOneofCase BinanceSigningInput::order_oneof_case() const {
  return BinanceSigningInput::OrderOneofCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace TW

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_TrustWalletCore_2eproto
